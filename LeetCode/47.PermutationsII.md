## [46. Permutations](https://leetcode.com/problems/permutations-ii/)


Given a collection of numbers, `nums`, that might contain duplicates, return _all possible unique permutations **in any order**._

**Example 1:**

```
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**Example 2:**

```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**Constraints:**

*   `1 <= nums.length <= 8`
*   `-10 <= nums[i] <= 10`



## Solution

- Approach 1: Sorting

```go
```



- Approach 2

> Instead of using an additional array to store prefix, we can use a point `i` and `A[0..i)` stands for prefix. The prefix can then be extended by swapping values in `A[i:]` with `A[i]`.

```go
func permuteUnique(nums []int) [][]int {
    var result [][]int
    helper(nums, 0, &result)
    return result
}

// A[0..i) is fixed, i.e. prefix = A[0..i)
// then permute A[i:]
func helper(nums []int, i int, result *[][]int) {
    n := len(nums)
    if i == n {
        // add prefix to result (as i == n, prefix is the whole array)
        tmp := make([]int, n)
        copy(tmp, nums)
        *result = append(*result, tmp)
        return
    }

    // consider position i, we should not put same number twice at this position
    // use a set to store values in A[i..n)
    set := make(map[int]bool)
    for j := i; j < n; j++ {
        if set[nums[j]] {
            continue
        }

        // swap values at i and j, extend prefix
        nums[i], nums[j] = nums[j], nums[i]
        set[nums[i]] = true
        // then permute A[i+1:]
        helper(nums, i+1, result)
        // clean up: restore states
        nums[i], nums[j] = nums[j], nums[i]
    }
}
```