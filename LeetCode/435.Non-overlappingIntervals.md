## [435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)


Given an array of intervals `intervals` where <code>intervals[i] = [start<sub style="display: inline;">i</sub>, end<sub style="display: inline;">i</sub>]</code>, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.

**Example 1:**

```
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
```

**Example 2:**

```
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
```

**Example 3:**

```
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

**Constraints:**

*   <code>1 <= intervals.length <= 10<sup>5</sup></code>
*   `intervals[i].length == 2`
*   <code>-5 * 10<sup>4</sup> <= start<sub style="display: inline;">i</sub> < end<sub style="display: inline;">i</sub> <= 5 * 10<sup>4</sup></code>



## Solution

- Dynamic Programming	$Time: O(n^2), Space: O(n)$ 	(Time Limit Exceeded)

> Can sort by start or end.

```go
// Sort by end
// M(j): max # of non-overlapping intervals that ends with A[j]
// M(-1) = 0        // empty
// M(j) = 1+M(j-1)    , if A[j] does not overlap with A[j-1]
//      = M(j-1)      , otherwise
func eraseOverlapIntervals(intervals [][]int) int {
    n := len(intervals)
    // sort by end
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][1] < intervals[j][1]
    })

    dp := make([]int, n)
    for i := range dp {
        dp[i] = 1
    }

    maxCount := 0
    for j := 0; j < n; j++ {
        for i := 0; i < j; i++ {
            if intervals[i][1] <= intervals[j][0] {
                dp[j] = max(dp[j], dp[i]+1)
            }
        }
        maxCount = max(maxCount, dp[j])
    }
    return n - maxCount
}
```



- Sorting + Greedy	$Time: O(nlogn), Space: O(1)$ 

> MUST sort by end.

```go
// Sort by end
// M(j): max # of non-overlapping intervals that ends with A[j]
// M(-1) = 0        // empty
// M(j) = 1+M(j-1)    , if A[j] does not overlap with A[j-1]
//      = M(j-1)      , otherwise
func eraseOverlapIntervals(intervals [][]int) int {
    n := len(intervals)
    // sort by end
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][1] < intervals[j][1]
    })

    maxCount := 0
    preEnd := math.MinInt
    for _, interval := range intervals {
        start, end := interval[0], interval[1]
        if start >= preEnd {	// do not overlap
            maxCount++
            preEnd = end
        }
    }
    return n - maxCount
}
```

